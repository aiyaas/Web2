/** 
 * Contains the list of /intents.json data types
 * Ideas by, as defined by (DARMAWN) copyright changes are prohibited 
 * 
 * @return
 */
/**
 * @since v12.0.37
 */
"use strict";
const _ConversationScheme = data;
/** 
 * const HarmCategory = require("./_shims/HarmCategory.json");
 * const _ConversationScheme = require("./_shims/intents.json");
 * const {
 *   LEVENSHTEIN_DISTANCE_OF // Word pattern matching scheme
 * } = require("./schema/core.d.ts");
 */
/**
 * Unreasonable request initiation to be blocked 
 * 
 * @param {(string) => HarmProbability} declaration function to detect HARM_CATEGORY_DANGEROUS_CONTENT and sensor sensitive message
 */
/**
 * function HarmProbabilityBlocked(catchs){
 *  let words = catchs.toLowerCase().split(" ");
 *  for (let i = 0; i < words.length; i++) {
 *    if (HarmCategory["HARM_CATEGORY_DANGEROUS_CONTENT"].includes(words[i].toLowerCase())){
 *       words[i] = "*".repeat(words[i].length);
 *    }
 * }
 * return words.join(" ");
 * }
 */
  
/**
 * MIT Licensed
 * Copyright(c) May 24, 2022 (INCE) and (REAPL)
 * Copyright(c) 2024 (Darmawan)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   (http://www.apache.org/licenses/LICENSE-2.0)
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Classes for Generative Model Construction Reapl
 * @public 
 */
class ReaplAI {
   /**
    * Constructor and default _answer
    * @param {_answer} => Customize I/O scheme
    */
   constructor(_answer) {
      this._SchemaType = _answer || _ConversationScheme;
      /** Minimum similarity score required for a match */
      this._AuthLimitations = 0.4;
      /** Rate at which the model adapts to new patterns */
      this._learningRate = 0.3;
      this.dynamicMemory = [];
   }
   
   /** Calculate Similarity Score between two words */
   SimilarityScoreMatching(_a_words, _b_words) {
      let comparisons = 0;
      
      /** Iterate over each word in both strings */
      _a_words.split(" ").forEach(wordA => {
         _b_words.split(" ").forEach(wordB => {
            comparisons = Math.max(comparisons, 1 - LEVENSHTEIN_DISTANCE_OF(wordA, wordB) / Math.max(wordA.length, wordB.length));
         });
      });
      return comparisons;
   }
   
   /**
    * Add new commands to the model dynamically and adaptively
    * @param {(string) => input} User feedback
    * @param {(string) => output} Expected response from the model
    */
   adaptToUserInput(input, output) {
      const _splits = input.toLowerCase().split(" ");
      
      /** Look for any similar patterns that already exist */
      let existingIntent = this._SchemaType["intents"].find(intent => intent["patterns"].some(pattern => pattern.includes(input.toLowerCase())));
      
      /** Update response and increase priority if pattern already exists */
      if (existingIntent) {
         existingIntent.responses.push(output);
         existingIntent.weight = (existingIntent.weight || 1) +1;
      } else {
         /** Create a new pattern with an emphasis on adaptation weight */
         this._SchemaType["intents"].push({
            models: `${this._models}-${Date.now()}`,
            vol_date: [new Date()],
            patterns: _splits,
            responses: [output],
            weight: 1
         });
      }
      this.dynamicMemory.push({ input: _splits, output: output });
      /** Update rate to update the adaptation model */
      return this._learningRate += 0.01;
   }

   /** Update ReaplGenerativeAIRequestInput with interactive model from SimilarityScoreMatching */
   /**
    * Find Best Intent Match from require('./_shims/conversation.json') database to determine the accuracy of FloraAI response
    *
    * @param {(string) => _captureInput} User input for intent indication
    * @returns {(Object) => null} Best match means or null if there is no match between the user command and FloraAI
    */
   ReaplGenerativeAIRequestInput(_captureInput) {
      const _splits = _captureInput.toLowerCase().split(" ").filter(word => word.length > 0);
      let MaxScore = 0;
      let absolute = null;

      this._SchemaType["intents"].forEach(intents => {
         let intents_score = 0;
         _splits.forEach(words => {
            const patternScores = intents["patterns"].map(patterns => this.SimilarityScoreMatching(words, patterns.toLowerCase()));
            intents_score += Math.max(...patternScores);
         });
         const _AverageScore = intents_score/_splits.length;
         
         /** Save the intent with the highest score */
         if (_AverageScore > MaxScore && _AverageScore >= this._AuthLimitations) {
            MaxScore = _AverageScore;
            absolute = intents;
         }
      });
      return absolute;
   }
   
   /** 
    * Definition of input handling function with defaultParseResponse
    * @param {(string) => defaultParseResponse} use handling this message
    */
   defaultParseResponse(_query) {      
      const message = this.ReaplGenerativeAIRequestInput(_query); 
      const MessageFailed = ["Maaf, saya tidak memahami perintah anda!", "Saya tidak memahami perintah tersebut, bisakah Anda menjelaskannya lagi? dengan lebih detail.", "Maaf, saya belum mengenal perintah itu. Bisakah Anda memberikan perintah lain?", "Saya masih tahap pembelajaran. Mungkin Anda dapat mencoba perintah yang lain?", "Maaf, saya tidak memahami apa yang anda perintahkan! karena keterbatasan saya dalam analisis data.", "Could you rephrase your question?", "I'm here to help! Try asking something different.", "I couldn't find an answer for that, try another query."];
      
      /** Adaptive learning to user commands */
      this.adaptToUserInput(_query, message);
      
      /**
       * Response handling defaultParseResponse 
       *
       * @params {(return) => message} block to get the result of user command 
       * @params {(return) => MessageFailed} defaults Handling response if the response given is not available in this._SchemaType
       */
      if (message) {
         return message["responses"][Math.floor(Math.random() * message["responses"].length)];
      } else {
         return MessageFailed[Math.floor(Math.random() * MessageFailed.length)];
      }
   }
}

/**
 * Module exports type ECMAScript.
 *
 * Object.defineProperty(exports, "__esModule", { value: true });
 * exports.ReaplAI = ReaplAI;
 */


